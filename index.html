---
layout: default
comments: true
---
<div class="home">

  <h1 class="post-title">Taming Complexity In Software Development</h1>
  <br /><br />
  Most software products and services on the market today are either prohibitively expensive, or prohibitively unusable, or both. In addition to that, most ongoing software projects are notoriously late, costing much more than originally estimated. To add insult to an injury, many software development projects tend to deliver products/services that are unreliable, buggy, slow, in a word -- crippleware.
  <br /><br />
  The main cause of this veritable fiasco is <em>complexity</em>. Seems like it's almost impossible for many, if not most software products not to be complex, to the point of being unmaintainable. This issue is now reaching catastrophic proportions, and a remedy to this unbearable situation is long overdue. This site is dedicated to exposing the diagnostics of the failed software delivery, and to offer some guidelines on how to go about uprooting this pesky complexity.
  <br /><br />
  The simplified diagram below offers an initial glimpse into the problem. When the software development project begins, things are lighthearted, manageable, and it's easy for the development teams to make quick progress. But as the software product keeps growing, complexity enters the picture, and the dizzying explosive growth of the product quickly brings the delivery pace to a grinding halt. There comes a point when team members realize they've painted themselves in a corner. At that point, one thought invariably enters the conversation: "If only we knew, early on in the project, the things we know now, we could've avoided this disaster!"
  <br /><br />
  In the final analysis, it is very desirable to be able to learn from one's mistakes and then travel back in the past and correct the course of action. But since no one has a time machine, this idea gets summarily dismissed. However, in the world of software development it is possible to learn from one's mistakes and then travel back in the past and correct what's already been done. This time machine could be called "putting soft back into software". This site discusses some approaches that could be used to build this time machine.
  <br /><br />


  <img src="https://github.com/alexbunardzic/alexbunardzic.github.io/blob/master/assets/Complexity%20curve%20graph.png?raw=true" />


  <br /><br />
  <p class="rss-subscribe">subscribe <a href="{{ "/feed.xml" | prepend: site.baseurl }}">via RSS</a></p>


</div>
