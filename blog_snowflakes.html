<!DOCTYPE html>
<html>
<head>
    <title>Digital Exprt</title>
    <link type="text/css" rel="Stylesheet" href="stylings.css" />
    
    <link type="text/css" rel="Stylesheet" href="stylings.css" />
    <script src="//code.jquery.com/jquery-2.1.1.min.js"></script>
    <script src="/Scripts/jquery.unobtrusive-ajax.min.js" type="text/javascript"></script>
    <script src="/Scripts/spin.min.js" type="text/javascript"></script>
    <script src="//cdn.optimizely.com/js/2184950954.js"></script>
    <script src="w3data.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js"></script>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Digital Exprt</title>
    <meta name="description" content="">

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
        
    <meta property="og:title" content="Sign up">
    <meta property="og:type" content="article">
    <meta property="og:url" content="">
    <meta property="og:description" content="">
    <meta property="og:site_name" content="digitalexprt"> 
</head>
<body >
    <div id="headerDiv"></div>

    <div id="content_layout">
        
      <main id="main-content" role="main" class="">
       <div class="wrapper">
        <section class="section-sign-up">
          <header class="block-main-header">
            <!-- content here -->
                <h2><b>Digital Exprt Blog</b></h2>
                <br /><br />

<h2>Abolish Unique Precious Snowflakes</h2>
<br />
<img src="./assets/snowflakes.jpeg" width="600" />
<br /><br />
<p>Software professionals (software architects, designers, engineers, developers) are phenomenally good at creating <em>bloat</em>. Give any of those professionals a challenge, a problem, and watch them go away and then later on come back with bloated ‘solution’. It is extremely unlikely (verging on literally impossible) to see software professionals produce something lean, something not incredibly bloated.</p>
<br />
<p>We gotta ask ourselves a question: why is that? What is it in the discipline of software engineering/development that is so prone to producing bloat?</p>
<br />
<p>I think the answer lies in the ingrained perception that software code is a <em>unique precious snowflake</em> that has been lovingly crafted by some incredibly smart people. Of course, such carefully crafted precious snowflake commands a very high retail price.</p>
<br />
<p>That arrangement is good for creators of this bloat, but is bad for the paying customers. It is also bad for poor people who are then saddled with maintaining the steaming pile of bloat. It is therefore high time we break the vicious cycle and call a spade a spade. In other words, time to face the fact that there are no unique precious snowflakes in the world of software development. Ergo, no amount of hand crafted code should ever command high price tags.</p>
<br /><br />
<h3>Real World Analogy</h3>
<br />
<p>It may help if we illustrate the current anomaly that is plaguing the world of software with an analogy from the real world. Suppose we teach someone how to build a house using bricks. Those bricks are standardized, uniform in size, perfect for building a sturdy house. So everything seems perfectly fine.</p>
<br />
<p>Suppose now we call these newly minted house building experts and ask them to build a bigger house. Are we expecting them to go back to the drawing board and design and build bigger bricks? No. We expect them to understand that to build a bigger house all they need is <em>more of the same</em>. More bricks, that’s all!</p>
<br />
<p>But for some reason in the world of software development, that’s not how things work. Whenever we ask any software development team to build a larger system, the first thing they’ll do is go off into a deep dive creating much larger building blocks. Hence bloat!</p>
<br />
<p>Why do we say that’s bloat? Because working with and maintaining bigger, more complex building blocks is a chore prone to all kinds of errors. Software professionals don’t seem able to work with the <em>more of the same</em> principle. They’ve been trained, from the get go, to only focus on building larger, more complex unique precious snowflakes.</p>
<br /><br />
<h3>How To Avoid Bloat?</h3>
<br />
<p>In software, bloat seems inevitable. After all, that’s how software professionals have been trained, and that’s how many software vendors are making their fortunes. Software bloat seems very lucrative for software professionals.</p>
<br />
<p>In order to avoid this expensive and detrimental bloat, we need to stop appreciating unique precious snowflakes. So even if we were to agree on the undesirability of celebrating precious snowflakes, it still isn’t clear how would one do software development without this pervasive, ubiquitous bloat?</p>
<br />
<p>Here is the present situation: our world is a complex, complicated place. Hence our business objectives cannot help but also be complex. Currently, in order to model our business objectives and map them to software constructs, we always use complex structures. After all, mapping conceptual solution onto a complex real world system requires equal degree of complexity, no?</p>
<br />
<p>While the above is correct, it is <em>how</em> we go about this mapping of the complex concepts onto a complex real world situation that is of paramount importance. It’s similar to how we go about building a bigger house — instead of creating more complex building blocks, we can opt to go with <em>more of the same</em> principle. The important epiphany in software development comes at the moment when we realize that we can <em>meet complex objectives</em> by utilizing a <em>large number of small simple steps</em>.</p>
<br />
<p>Each small simple step is not a unique, precious snowflake (does not require carefully crafted code). Therefore, it’s not a bloat. The only smarts that a system comprising of a large number of small simple steps has is in the <em>arrangement of those steps</em>. To change the mapping of a complex objective, we don’t change the building blocks (i.e. any of those small simple steps). We only change the arrangement of those steps. No need to ever touch the originally implemented software code.</p>
<br />
<p>Using a more technical jargon, we can say that simple software components (the building ‘bricks’) need to be arranged into more or less <em>complex networks</em>. If the execution of a software program needs to be changed, we don’t modify the building bricks (the components, meaning we don’t touch the source code); we change <em>the layout of the network</em> that is comprised of those <em>immutable components</em>.</p>
<br /><br />
<h3>How Does The Network Execute The Program?</h3>
<br />
<p>Unlike in the antiquated world of sequential programming, the network does not rely on a localized execution of the program. Instead, the network relies on two fundamental concepts:</p>
<br />
<p>1. Addresses</p>
<p>2. Messages</p>
<br />
<p>In the network-centric computing, messages are being pushed from address to another address. <em>The progression of messages through the network is the actual execution of the program</em>. And since the fundamental building blocks (bricks, or components) are not unique precious snowflakes (are <strong>not</strong> bloated), the only smarts needed for correct execution is found in the layout of the network. And as we’ve mentioned, to modify the execution of the program, we only modify the layout of the network. We <strong>never</strong> modify the simple building blocks of the network.</p>
<br />
<p>In this arrangement, <em>the message is the application</em>!</p>
<br /><br />
<h3>Conclusion</h3>
<br />
<p>The time has finally come for software development professionals to abandon the obsession with unique precious snowflakes (i.e. software source code) and to embrace the standardized approach to building systems. Drawing from some examples form the real world engineering, we saw how desirable it is to avoid bloat at all costs.</p>
<br />
<p>The next thing one needs to do after reaching that epiphany is figure out how to go about avoiding that bloat. It is recommended to abandon the obsession with programming code, and instead focus on the skills needed to cleverly design complex networks. Those networks consist of ultra simple components that know how to keep pushing messages via the addressing system. That way, the risk of component bloat (the bloat creeping into the source code) gets completely mitigated.</p>
<br /><br />
<p>
                </p>
          </header>
       </div>
      </main>
    </div>

    <div id="footerDiv"></div>

</body>
</html>

    <script> 
      $(function(){
        $("#headerDiv").load("theheader.html");
        $("#footerDiv").load("thefooter.html");
      });  
    </script>       
