---
layout: post
title: "How Is Complexity Causing Software to Harden?"
date: 2015-07-04T11:31:23-07:00
---

Complexity is the opposite of [simplicity](https://en.wikipedia.org/wiki/Simplicity). Often times we hear that simplicity is the state where there is nothing left to take away. What we're left with when we've reached the state where there is nothing left to be taken away is the essential. This, then, is synonimous with the final achievement.

When achieving simplicity in our software code, we have ensured that the product we're working on remains soft (i.e. plable, maleable, open to growth, change). Conversely, when failing to achieve simplicity, we end up with complexity (incidental or accidental), which means we fail to retain plability, maleability. Our product, saddled with complexity, turns into a hardened surface. Such hardened surface is pushing back, resisting any and all attempts to change it.

So how do we know if we're remaininig on the right track while writing code, and how do we know that we're not abandoning simplicity and inadvertently introducing unwanted complexity? It's a tricky question, and recognizing the silent creeping in of complexity is indeed a skill that takes time to develop. But there are some guidelines that are useful to keep in mind while designining and developing products and services.

The first thing to remember is that complexity is always easy. It's the easiest thing that comes to mind when pondering how to solve a problem. Why is that the case? Simply put, we all tend to go with whatever it is we're most familiar with.