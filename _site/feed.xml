<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Putting Soft Back Into Software</title>
    <description>Discussion about software development and software engineering. Practical points and tips illustrating how to bring &#39;soft&#39; back into software.  Also, exploring the possibilities of writing deterministic programs using Ruby and Ruby on Rails.
</description>
    <link>https://alexbunardzic.github.io/</link>
    <atom:link href="https://alexbunardzic.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 04 Jul 2015 16:48:43 -0700</pubDate>
    <lastBuildDate>Sat, 04 Jul 2015 16:48:43 -0700</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>How Is Complexity Causing Software to Harden?</title>
        <description>&lt;p&gt;Complexity is the opposite of &lt;a href=&quot;https://en.wikipedia.org/wiki/Simplicity&quot;&gt;simplicity&lt;/a&gt;. Often times we hear that simplicity is the state where there is nothing left to take away. What we’re left with when we’ve reached the state where there is nothing left to be taken away is the essential. This, then, is synonimous with the final achievement.&lt;/p&gt;

&lt;p&gt;When achieving simplicity in our software code, we have ensured that the product we’re working on remains soft (i.e. plable, maleable, open to growth, change). Conversely, when failing to achieve simplicity, we end up with complexity (incidental or accidental), which means we fail to retain plability, maleability. Our product, saddled with complexity, turns into a hardened surface. Such hardened surface is pushing back, resisting any and all attempts to change it.&lt;/p&gt;

&lt;p&gt;So how do we know if we’re remaininig on the right track while writing code, and how do we know that we’re not abandoning simplicity and inadvertently introducing unwanted complexity? It’s a tricky question, and recognizing the silent creeping in of complexity is indeed a skill that takes time to develop. But there are some guidelines that are useful to keep in mind while designining and developing products and services.&lt;/p&gt;

&lt;p&gt;The first thing to remember is that complexity is always easy. It’s the easiest thing that comes to mind when pondering how to solve a problem. Why is that the case? Simply put, we all tend to go with whatever it is we’re most familiar with.&lt;/p&gt;
</description>
        <pubDate>Sat, 04 Jul 2015 11:31:23 -0700</pubDate>
        <link>https://alexbunardzic.github.io/2015/07/04/how-is-complexity-causing-software-to-harden.html</link>
        <guid isPermaLink="true">https://alexbunardzic.github.io/2015/07/04/how-is-complexity-causing-software-to-harden.html</guid>
        
        
      </item>
    
      <item>
        <title>Complexity is the Enemy</title>
        <description>&lt;p&gt;The reason why any software product tends to quickly harden into a surface that resembles hardware is very simple – it all boils down to &lt;a href=&quot;https://en.wikipedia.org/wiki/Complexity&quot;&gt;complexity&lt;/a&gt;. Complexity is the symptom of sloppy thinking. It was Mark Twain who once sent a letter to a friend apologizing for the excessive length – he claimed he didn’t have enough time to write a shorter letter. Seems counter-intuitive at first (doesn’t it require more time to write a very long letter than it would take to write a shorter one?), but Twain’s statement is absolutely true. It is very easy to scribble pages upon pages of run-on sentences. It gets really hard to write a letter that is short and to the point and that conveys the message clearly.&lt;/p&gt;

&lt;p&gt;The same holds true for software. When writing software code, it gets real easy to churn thousands upon thousands on lines of sloppy, poorly thought out code. Being verbose is easy, being succinct and simple is hard.&lt;/p&gt;
</description>
        <pubDate>Sat, 04 Jul 2015 11:15:27 -0700</pubDate>
        <link>https://alexbunardzic.github.io/2015/07/04/complexity-is-the-enemy.html</link>
        <guid isPermaLink="true">https://alexbunardzic.github.io/2015/07/04/complexity-is-the-enemy.html</guid>
        
        
      </item>
    
      <item>
        <title>Why Software Tends to Harden?</title>
        <description>&lt;p&gt;The nature of a software product is to be soft, meaning maleable, pliable, easy to mold and modify. The very word ‘soft’ is in the name of the product – software.&lt;/p&gt;

&lt;p&gt;Isn’t it surprising to see how many, if not most of the software products tend to harden as we work on them? We’ve all been there (and most likely more often than once): start some software development project, and get excited at first while observing how quickly we make useful and significant changes and continue adding value. But the initial buzz quickly wears off. Soon enough we get to the point where we realize that, all of a sudden, the honey moon appears to be over. Our shiny new product, that was up until yesterday so eager to emnbrace change and go into any direction we ask it to go, has now turned into a grumpy old curmudgeon.&lt;/p&gt;

&lt;p&gt;This is the much dreaded point where we hit the wall, full speed, and experience rude awakening that’s telling us that our product has hardened into a solid, impenetrable mass. Any attempt to add new features, or modify existing features, or even remove superfluous features, turns into a disaster. Touch this newly hardened software product, and it will bite back. All of a sudden, our codebase become averse to change. At this point, many teams resign to the fact that they have built a so called ‘ball of mud’, and label it ‘legacy’ and then learn to live with its quirks and foibles. Or, as is often the case, many team members at that point quit, and start looking for another opportunity for a fresh start.&lt;/p&gt;

&lt;p&gt;This seemingly inevitable pattern is the bane of software developers’ existence. It truly spoils all the joy we experience as we embark upon a brand new, exciting project. So the most pressing question for every software developer/engineer/programmer is – &lt;em&gt;why&lt;/em&gt;? Why does each software development project inevitably have to erode and be ttransformed from soft and pliable to hardened and immovable legacy writeoff?&lt;/p&gt;

&lt;p&gt;Solve the above question, and you’ve made the world a better place. Easier said than done, but we’ll try to supply some diagnostic, forensics, as well as some remedies in the articles to follow here.&lt;/p&gt;

</description>
        <pubDate>Sat, 04 Jul 2015 10:30:54 -0700</pubDate>
        <link>https://alexbunardzic.github.io/2015/07/04/why-software-tends-to-harden.html</link>
        <guid isPermaLink="true">https://alexbunardzic.github.io/2015/07/04/why-software-tends-to-harden.html</guid>
        
        
      </item>
    
      <item>
        <title>Software Development or Software Engineering?</title>
        <description>&lt;p&gt;When it comes to building and delivering software, things seem somehow different from the way they appear in other, non-virtual activities. For example, in the construction business we may have developers and engineers, but their roles seem to differ from the roles assigned to them in the software delivery business. In the construction business, developers are focused on managing the &lt;em&gt;process&lt;/em&gt; of building and delivering, while engineers are focused on ensuring the &lt;em&gt;product quality&lt;/em&gt; by adhering to engineering principles. In software, on the other hand, engineers seem focused on managing the &lt;em&gt;process&lt;/em&gt; of software delivery, while developers tend to narrow their attention down to ensuring the &lt;em&gt;product quality&lt;/em&gt; by adhering to the principles of solid programming practices.&lt;/p&gt;

&lt;p&gt;This perception may be skewed, or even deceptive, but whichever the case may be, we need to understand the differences between software development and software engineering. So, in my view:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Software development:&lt;/strong&gt; the art and craft of producing computer programs that are deterministic (or near-deterministic) by the virtue of their purity&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Software engineering:&lt;/strong&gt; the art and science of accepting the requirements coming form upstream business and then running with those requirements by making sure the development team follows the ‘building from the business outcomes’, or ‘building from outside in’ guidelines&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We will be making a distinction between these two roles (i.e. software development and software engineering) as we’re making progress in the subsequent articles. My intention is to focus more on the sofware development side of the business (e.g. how to work toward ensuring that the code we produce delivers deterministic, predictable results). I am however fully aware of the fact that just delivering predictive, deterministic code is not sufficient – we also need to deliver predictive, deterministic process which will ensure we remain predictably time boxed and are staying within budgetary constraints.&lt;/p&gt;

</description>
        <pubDate>Fri, 03 Jul 2015 20:07:03 -0700</pubDate>
        <link>https://alexbunardzic.github.io/2015/07/03/development-or-engineering.html</link>
        <guid isPermaLink="true">https://alexbunardzic.github.io/2015/07/03/development-or-engineering.html</guid>
        
        
      </item>
    
  </channel>
</rss>
